<!doctype html>
<html lang="en_US">
<head>
  <meta charset="utf-8"/>
  <title>FPBench</title>
  <link rel="stylesheet" type="text/css" href="../fpbench.css">
</head>
<body>

<header>
  <img id='logo' src='../img/logo.png' height='150' alt='FPBench Logo' />
  <h1>FPBench</h1>
</header>

<main>
<header>
  <h1>FPBench 1.0 standards</h1>

  <p>
    <a href="../../">FPBench</a> is a standard benchmark suite for the
    floating point community to organize its efforts around. The
    benchmark suite is organized around a common format and a common set
    of measures of accuracy. FPBench 1.0 is the first version of this
    common format and set of measures.
  </p>

  <p>
    FPBench 1.0 standardizes:
  </p>

  <ol>
    <li><a href="#fpcore">The FPCore input format</a></li>
    <li><a href="#props">Properties of FPCore benchmarks</a></li>
    <li><a href="#measure">Standard measures of error</a></li>
  </ol>
</header>

<section id="fpcore">
<header>
  <h2>FPCore benchmark format</h2>

  <p>
    FPCore is the format used for FPBench benchmarks. It is a simple
    functional programming language with conditionals and simple
    loops. The syntax is an easy-to-parse S-expression syntax.
  </p>
</header>

  <figure>
    <pre><code class="fpcore">(FPCore (x0)
  :name "Sine Newton"
  :cite (darulova-kuncak-2014)
  :pre (< (abs x0) 1)
  (while (< i 10)
    ([x x0 (- x (/ (+ (+ (- x (/ (pow x 3) 6.0)) (/ (pow x 5) 120.0))
                      (/ (pow x 7) 5040.0))
                   (+ (+ (- 1.0 (/ (* x x) 2.0)) (/ (pow x 4) 24.0))
                      (/ (pow x 6) 720.0))))]
     [i 0 (+ i 1)])
    x))</code></pre>
    <caption>An example FPCore program, from the <data value="benchmarks/rosa.fpcore" class="suite-name">rosa</data> suite.</caption>
  </figure>

  <section>
  <h3>Syntax</h3>

  <p>
    The syntax is a simple S-expression syntax modeled on SMT-LIB2.
    The following grammar describes an FPCore benchmark.
  </p>
  
  <figure>
    <dl class="grammar">
      <dt id="g:fpcore">FPCore</dt>
      <dd>( FPCore (<a href="#g:symbol" title="Free variables in benchmark">symbol</a>)*
        <a href="#g:property" title="Metadata properties of the benchmark">property</a>*
        <a href="#g:expr" title="Benchmark expr">expr</a> )
      </dd>

      <dt id="g:expr">expr</dt>
      <dd><a href="#g:numeral">numeral</a></dd>
      <dd><a href="#g:decimal">decimal</a></dd>
      <dd><a href="#g:constant">constant</a></dd>
      <dd><a href="#g:symbol">symbol</a></dd>
      <dd>( <a href="#g:operation">operation</a> <a href="#g:expr">expr</a>* )</dd>
      <dd>( if <a href="#g:expr" title="conditional">expr</a> <a href="#g:expr" title="Branch if condition is true">expr</a> <a href="#g:expr" title="Branch if condition is false">expr</a> )</dd>
      <dd>( let ( [ <a href="#g:symbol" title="Variable being bound">symbol</a> <a href="#g:expr" title="Value of variable">expr</a> ]* ) <a href="#g:expr">expr</a> )</dd>
      <dd>( while <a href="#g:expr">expr</a> ( [ <a href="#g:symbol" title="Variable mutated in loop">symbol</a> <a href="#g:expr" title="Initial variable value">expr</a> <a href="#g:expr" title="Update expr for variable">expr</a> ]* ) <a href="#g:expr">expr</a> )</dd>
      
      <dt id="g:property">property</dt>
      <dd>:<a href="#g:symbol">symbol</a> <a href="#g:expr">expr</a></dd>
      <dd>:<a href="#g:symbol">symbol</a> <a href="#g:string">string</a></dd>
      <dd>:<a href="#g:symbol">symbol</a> ( <a href="#g:symbol">symbol</a>* )</dd>
    </dl>
    <caption>High-level grammar of FPCore. The tokens <a href="#g:constant">constant</a> and <a href="#g:operation">operation</a> are defined below, while all other tokens are defined as in <a href="http://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB 2.5</a>. </caption>
  </figure>
  
  <p>
    In this grammar, an <a href="#g:fpcore">FPCore</a> term describes
    a single benchmark, with a set of free variables, a collection of
    metadata properties, and the floating-point expression defining
    the benchmark. The additional tokens <a id="g:symbol">symbol</a>,
    <a id="g:numeral">numeral</a>, <a id="g:decimal">decimal</a>,
    and <a id="g:string">string</a> are defined exactly as in 
    <a href="http://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB
    2.5</a>. White-space is ignored, and lines starting with the
    semicolon (<code>;</code>) are treated as comments and ignored.
  </p>

  <h3 id="g:operation">Supported operations</h3>

  <aside>
    Arithmetic operations are binary, because floating-point
    arithmetic is non-associative. Since boolean operations are,
    however, exact, they may be given arbitrarily many arguments.
  </aside>

  <p>
    All floating-point functions from
    C11 <a href="http://en.cppreference.com/w/c/numeric/math"><code>math.h</code></a>
    are supported. These functions are a superset of the
    floating-point intrinsics from Fortran 2003. The arithmetic
    functions <code>+</code>, <code>*</code>, <code>-</code>,
    and <code>/</code> are supported. All are binary operators,
    except <code>-</code>, which can also be unary negation. For the
    C11 functions, the un-suffixed names are used
    (use <code>exp</code>, not <code>expf</code>).
  </p>
  
  <p>
    Following IEEE754 and common C and Fortran implementations, FPCore
    does not prescribe an accuracy to any mathematical functions
    except the arithmetic operators, <code>sqrt</code>,
    and <code>fma</code>. If the exact accuracy is important, we
    recommend that benchmark users declare the implementation used and
    its accuracy.
  </p>

  <p>
    Additionally, the comparison operators <code>&lt;</code>,
    <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>,
    <code>==</code>, and <code>!=</code> are supported, as are the
    boolean operators <code>and</code>, <code>or</code>,
    and <code>not</code>.</p>

  <p>
    The comparison operators and boolean
    operators <code>and</code> and <code>or</code> take an arbitrary
    number of arguments. A comparison operator with more than two
    operators is interpreted as the conjuction of all ordered pairs of
    arguments. For example, <code>(&lt; 1 2 3)</code> is true
    and <code>(!= 1 2 1)</code> is false. In other
    words, <code>==</code> tests that all its arguments are
    equal; <code>!=</code> tests that all its arguments are distinct;
    and <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>,
    and <code>&gt;=</code> test that their arguments are sorted in the
    appropriate order.
  </p>
  
  <h3 id="g:constant">Supported constants</h3>

  <p>
    The floating-point constants <code>E</code>, <code>LOG2E</code>,
    <code>LOG10E</code>, <code>LN2</code>, <code>LN10</code>,
    <code>PI</code>, <code>PI_2</code>, <code>PI_4</code>,
    <code>1_PI</code>, <code>2_PI</code>, <code>2_SQRTPI</code>,
    <code>SQRT2</code>, and <code>SQRT1_2</code> are supported,
    defined just like their analogs in
    <a href="http://www.gnu.org/software/libc/manual/html_node/Mathematical-Constants.html">GNU libc</a>.
    This gives FPCore support for all constants
    commonly-provided by C and Fortran implementations. All constants
    are assumed to be the closest floating-point number to the
    mathematically-accurate value of the constant.
  </p>
  
  <p>
    Additionally, the boolean constants <code>TRUE</code>
    and <code>FALSE</code> are supported.
  </p>
  
  <h3>Semantics</h3>

  <p>
    Property values do not affect the semantics of an FPCore
    expression. However, the precision of floating-point values is
    usually specified using the <code>:type</code> property.
  </p>

  <p>
    Expressions return either floating-point values or boolean values.
    Operations that receive values of mixed or incorrect types, such
    a <code>(+ 1 TRUE)</code> are illegal and the results of
    evaluating them undefined.
  </p>

  <p>
    The semantics of function application are standard.
  </p>

  <p>
    The condition expression in a <code>if</code> is evaluated in order
    to determine which branch is evaluated to find the value of the
    expression. The condition expression must return a boolean, while
    both branches must return values of the same type.
  </p>

  <p>
    Bindings in a <code>let</code> expression are evaluated
    simultaneously. Thus, <code>(let ([a b] [b a]) (- a b))</code> is
    the same as <code>(- b a)</code> and <code>(let ([a 1] [b a])
    b)</code> is illegal unless <code>a</code> is available in the
    context. Sequential bindings are equivalent to
    nested <code>let</code>s.
  </p>

  <p>
    A while loop contains a conditional, a list of bound variables,
    and a return expression. The context for both the conditional and
    the return expression includes all of the bound variables. The
    while loop is evaluated by initializing all bound variables by
    evaluating the initial expression and then evaluating the
    conditional. If the conditional is false, the return expression is
    evaluated and its value returned. If the condition is false, the
    update expressions for each variable are evaluated, and then each
    bound variable is re-bound to the value of the update expression.
  </p>
  
  <p>
    For example, <code>(while (&lt; i 1) ([i 0 (+ i 1)]) i)</code> is
    evaluated by evaluating <code>0</code> to 0;
    binding <code>i</code> to 0;
    evaluating <code>(&lt; i 1)</code> to truth;
    evaluating <code>(+ i 1)</code> to 1;
    re-binding <code>i</code> to 1;
    evaluating <code>(&lt; i 1)</code> to falsehood;
    and finally evaluating <code>i</code> to 1.
  </p>
  
  <p>
    If a loop has multiple variables, all of the update expressions
    are evaluated before any variable is re-bound; in other words,
    the <emph>old</emph> values of every bound variable is used to
    evaluate the update expression.
  </p>
</section>
  
<section id="props">
  <header>
    <h2>FPCore metadata properties</h2>

    <p>
      The metadata properties allow describing additional information
      about each benchmark, such as their name, description,
      precision, citations, or preconditions. FPBench 1.0 defines the
      meaning of the following properties:
    </p>

    <dl class="code-terms">
      <dt>:name</dt>
      <dd>
        A string name for the benchmark. If a name is needed and not
        provided, we recommend using the body expression.
      </dd>
      
      <dt>:description</dt>
      <dd>
        A string description for the benchmark and its inputs. We
        recommend describing the physical meaning and units of inputs
        when applicable.
      </dd>
      
      <dt>:cite</dt>
      <dd>
        A list of symbols that describe the sources of the benchmark.
        We recommend making available a BibTeX file which uses the
        same symbols as keys.
      </dd>

      <dt>:type</dt>
      <dd>
        Describes the floating point precision used for floating point
        values in the expression, using the IEEE-754 names (such
        as <code>binary32</code> and <code>binary64</code>). If
        no <code>:type</code> property is specified, implementations
        should assume <code>binary64</code> floating-point values.
      </dd>

      <dt>:pre</dt>
      <dd>
        A precondition on inputs to the benchmark. Tools should not
        use points that fail the precondition to determine the
        accuracy of the benchmark.
      </dd>
    </dl>
    
    <p>
      Additionally, properties prefixed by the name of a tool (such
      as <code>:xxx-foobar</code>) are reserved for definition by that
      tool. Only that tool may define the meaning of those properties;
      other tools should not depend on the meaning of those
      properties, nor must the defining tool keep the meaning constant.
    </p>
    
    <p>
      Proposals for extensions to FPBench must not define additional
      un-prefixed properties; instead, they should use the proposal
      name as a prefix until the proposal is accepted into an FPBench
      version.
    </p>

  </header>
</section>

</main>
